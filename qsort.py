        # <퀵 정렬>
        # 
        #   시간 복잡도 -> 평균 : nlogn , 최악일 때 : n^2  
        #         
        # - 분할 정복 알고리즘의 하나로, 평균적으로 빠른 수행속도의 정렬 방법이다

        # 분할 정복이란?
        # - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는
        # 전략

        # 과정 설명
        # 1. 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.

        # 2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다.
        #  (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)

        # 3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
        #     - 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
        #     - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
        # 4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
        #     - 리스트의 크기가 0이나 1이 될 때까지 반복한다.
        
        # 참고 : https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html

class doQuick:
    def __init__(self):
        pass


    def quick_sort(self,arr): 



        # 메인 함수인 quick_sort()는 크게 sort()와 partition() 2개의 내부 함수로 나눠집니다. 
        
        # sort() 함수는 재귀 함수이며 정렬 범위를 시작 인덱스와 끝 인덱스로 인자로 받습니다. 
        # partition() 함수는 정렬 범위를 인자로 받으며 다음 로직을 따라서 좌우측의 값들을 정렬하고 분할 기준점의 인덱스를 리턴합니다. 
        # 이 분할 기준점(mid)는 sort()를 재귀적으로 호출할 때 우측 리스트의 시작 인덱스로 사용됩니다.

        # 리스트의 정 가운데 있는 값을 pivot 값을 선택합니다.
        # 시작 인덱스(low)는 계속 증가 시키고, 끝 인덱스(high)는 계속 감소 시키기위한 while 루프를 두 인덱스가 서로 교차해서 지나칠 때까지 
        # 반복시킵니다.

        # 시작 인덱스(low)가 가리키는 값과 pivot 값을 비교해서 더 작은 경우 반복해서 시작 인덱스 값을 증가시킵니다. 
        # (pivot 값보다 큰데 좌측에 있는 값을 찾기 위해)
        # 끝 인덱스(high)가 가리키는 값과 pivot 값을 비교해서 더 작은 경우 반복해서 끝 인덱스 값을 감소시킵니다.
        # (pivot 값보다 작은데 우측에 있는 값을 찾기 위해)
        
        # 두 인덱스가 아직 서로 교차해서 지나치치 않았다면 시작 인덱스(low)가 가리키는 값과 끝 인덱스(high)가 가리키는 값을 상호 교대(swap) 시킵니다. 
        # (잘못된 위치에 있는 두 값의 위치를 바꾸기 위해)

        # 상호 교대 후, 다음 값을 가리키기 위해 두 인덱스를 각자 진행 방향으로 한 칸씩 이동 시킵니다.
        # 두 인덱스가 서로 교차해서 지나치게 되어 while 루프를 빠져나왔다면 다음 재귀 호출의 분할 기준점이될 시작 인덱스를 리턴합니다.

        
        def sort(low, high):
            if high <= low: #high가 low보다 작거나 같을때까지 반복
                return

            mid = partition(low, high)
            sort(low, mid - 1)
            sort(mid, high)

        def partition(low, high):
            pivot = arr[(low + high) // 2]
            while low <= high:
                while arr[low] < pivot:
                    low += 1
                while arr[high] > pivot:
                    high -= 1
                if low <= high:
                    arr[low], arr[high] = arr[high], arr[low]
                    low, high = low + 1, high - 1
            return low

        return sort(0, len(arr) - 1)






